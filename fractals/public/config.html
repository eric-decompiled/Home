<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mix Config — Cross-Family Anchor Picker</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { background:#0a0a0a; color:#ccc; font-family:'Segoe UI',sans-serif; padding:12px; overflow-y:auto; }
h1 { color:#16c79a; font-size:18px; margin-bottom:2px; }
.sub { color:#555; font-size:11px; margin-bottom:10px; }

.degree-bar { display:flex; gap:6px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
.deg-btn { padding:5px 12px; border:2px solid #333; border-radius:4px; cursor:pointer;
  font-family:monospace; font-size:13px; font-weight:600; background:#111; transition:all 0.15s; }
.deg-btn.active { border-color:#fff; box-shadow:0 0 8px rgba(255,255,255,0.2); }
.deg-btn .dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:4px; vertical-align:middle; }

.actions { display:flex; gap:8px; margin-left:auto; }
.actions button { padding:5px 14px; background:#16c79a; border:none; border-radius:4px;
  color:#000; cursor:pointer; font-weight:600; font-size:12px; }
.actions button:hover { background:#1de9b6; }

.panels { display:flex; gap:12px; margin-bottom:12px; }
.panel { flex:1; min-width:0; }
.panel h2 { font-size:13px; color:#16c79a; margin-bottom:4px; }
.panel canvas { display:block; width:100%; border:1px solid #0f3460; border-radius:4px; cursor:crosshair; }

.bottom { display:flex; gap:16px; align-items:flex-start; }
.julia-wrap { }
.julia-wrap canvas { display:block; border:1px solid #0f3460; border-radius:4px; }
.julia-info { font-size:12px; color:#16c79a; margin-top:4px; font-family:monospace; }

.assign-info { font-size:12px; color:#888; margin-top:8px; font-family:monospace; line-height:1.8; }
.assign-info .row { display:flex; gap:8px; align-items:center; }
.assign-info .dot { display:inline-block; width:10px; height:10px; border-radius:50%; }
.assign-info .type-tag { font-size:10px; padding:1px 5px; border-radius:3px; background:#1a1a2e; color:#aaa; }

#status { font-size:11px; color:#555; margin-top:6px; }
</style>
</head>
<body>
<h1>Mix Config</h1>
<p class="sub">Select a degree, then click any panel to place its anchor. Mix fractal types freely.</p>

<div class="degree-bar" id="degree-bar">
  <div class="actions">
    <button id="export-btn">Copy TypeScript</button>
    <button id="clear-btn">Clear All</button>
  </div>
</div>

<div class="panels" id="panels"></div>

<div class="bottom">
  <div class="julia-wrap">
    <canvas id="julia-canvas" width="350" height="350"></canvas>
    <div class="julia-info" id="julia-info">Click a panel to preview Julia set</div>
  </div>
  <div class="assign-info" id="assign-info"></div>
</div>
<div id="status"></div>

<div style="margin-top:32px; border-top:1px solid #1a1a2e; padding-top:16px;">
  <h2 style="color:#16c79a; font-size:16px; margin-bottom:8px;">Shape Atlas</h2>
  <iframe src="/shape-atlas.html" style="width:100%; height:850px; border:1px solid #0f3460; border-radius:4px; background:#0a0a0a;"></iframe>
</div>

<script>
const PANEL_SIZE = 500;
const LOCUS_ITER = 200;
const JULIA_SIZE = 350;
const JULIA_ITER = 180;

const degreeNames = ['0','I','ii','iii','IV','V','vi','vii'];
const degreeColors = ['#888','#ff4444','#44aaff','#44dd88','#ffaa22','#ff66cc','#88ccff','#ffff44'];

// --- Fractal families ---
const families = [
  {
    id: 'burning-ship', label: 'Burning Ship', typeNum: 3,
    bounds: { rMin:-2.2, rMax:1.2, iMin:-2.0, iMax:0.8 },
    locus(cr, ci, maxIter) {
      let x=0,y=0;
      for (let i=0;i<maxIter;i++){const ax=Math.abs(x),ay=Math.abs(y);x=ax*ax-ay*ay+cr;y=2*ax*ay+ci;if(x*x+y*y>100)return i+1;}
      return 0;
    },
    julia(fx, fy, jR, jI, maxIter) {
      let x=fx,y=fy;
      for(let i=0;i<maxIter;i++){const ax=Math.abs(x),ay=Math.abs(y);x=ax*ax-ay*ay+jR;y=2*ax*ay+jI;if(x*x+y*y>4)return i+1;}
      return 0;
    },
  },
  {
    id: 'buffalo', label: 'Buffalo', typeNum: 9,
    bounds: { rMin:-1.6, rMax:1.4, iMin:-1.4, iMax:1.4 },
    locus(cr, ci, maxIter) {
      let x=0,y=0;
      for(let i=0;i<maxIter;i++){const ax=Math.abs(x),ay=Math.abs(y);x=ax*ax-ay*ay-ax+cr;y=2*ax*ay-ay+ci;if(x*x+y*y>100)return i+1;}
      return 0;
    },
    julia(fx, fy, jR, jI, maxIter) {
      let x=fx,y=fy;
      for(let i=0;i<maxIter;i++){const ax=Math.abs(x),ay=Math.abs(y);x=ax*ax-ay*ay-ax+jR;y=2*ax*ay-ay+jI;if(x*x+y*y>4)return i+1;}
      return 0;
    },
  },
  {
    id: 'celtic', label: 'Celtic', typeNum: 6,
    bounds: { rMin:-2.2, rMax:1.5, iMin:-1.6, iMax:1.6 },
    locus(cr, ci, maxIter) {
      let x=0,y=0;
      for(let i=0;i<maxIter;i++){const x2=x*x,y2=y*y;const nx=Math.abs(x2-y2)+cr;const ny=2*x*y+ci;x=nx;y=ny;if(x*x+y*y>100)return i+1;}
      return 0;
    },
    julia(fx, fy, jR, jI, maxIter) {
      let x=fx,y=fy;
      for(let i=0;i<maxIter;i++){const x2=x*x,y2=y*y;const nx=Math.abs(x2-y2)+jR;const ny=2*x*y+jI;x=nx;y=ny;if(x*x+y*y>4)return i+1;}
      return 0;
    },
  },
];

// --- State ---
let selectedDegree = 1;

// Each degree: { familyIdx, real, imag, radius }  or null
const anchors = new Array(8).fill(null);
// Default radius for new placements
const DEFAULT_RADIUS = 0.085;

// Per-panel state
const panelState = families.map((f, i) => ({
  canvas: null,
  locusBuffer: null,
  bounds: { ...f.bounds },
  zoomLevel: 1.0,
  origBounds: { ...f.bounds },
}));

// --- Degree bar ---
function buildDegreeBar() {
  const bar = document.getElementById('degree-bar');
  // Insert before actions div
  const actions = bar.querySelector('.actions');
  for (let deg = 1; deg <= 7; deg++) {
    const btn = document.createElement('div');
    btn.className = 'deg-btn' + (deg === selectedDegree ? ' active' : '');
    btn.dataset.deg = deg;
    btn.innerHTML = `<span class="dot" style="background:${degreeColors[deg]}"></span>${degreeNames[deg]}`;
    btn.addEventListener('click', () => selectDegree(deg));
    bar.insertBefore(btn, actions);
  }
}

function selectDegree(deg) {
  selectedDegree = deg;
  document.querySelectorAll('.deg-btn').forEach(b =>
    b.classList.toggle('active', parseInt(b.dataset.deg) === deg));
  const a = anchors[deg];
  if (a) showJulia(families[a.familyIdx], a.real, a.imag);
  redrawAllOverlays();
}

// --- Panel rendering ---
function renderLocus(familyIdx) {
  const f = families[familyIdx];
  const ps = panelState[familyIdx];
  const buf = ps.locusBuffer;
  const ctx = buf.getContext('2d');
  const b = ps.bounds;
  const img = ctx.createImageData(PANEL_SIZE, PANEL_SIZE);
  const d = img.data;
  const rStep = (b.rMax-b.rMin)/PANEL_SIZE;
  const iStep = (b.iMax-b.iMin)/PANEL_SIZE;
  const maxIter = Math.round(LOCUS_ITER * (1 + Math.log2(Math.max(1, ps.zoomLevel))));

  for (let py=0; py<PANEL_SIZE; py++) {
    const ci = b.iMin + py * iStep;
    for (let px=0; px<PANEL_SIZE; px++) {
      const cr = b.rMin + px * rStep;
      const esc = f.locus(cr, ci, maxIter);
      const idx = (py*PANEL_SIZE+px)*4;
      if (esc === 0) {
        d[idx]=8; d[idx+1]=8; d[idx+2]=16;
      } else {
        const t = Math.sqrt(esc / maxIter);
        d[idx]=Math.round(12+t*50); d[idx+1]=Math.round(20+t*100); d[idx+2]=Math.round(35+t*80);
      }
      d[idx+3]=255;
    }
  }
  ctx.putImageData(img, 0, 0);
}

function cToPixel(familyIdx, r, i) {
  const b = panelState[familyIdx].bounds;
  return {
    x: (r - b.rMin) / (b.rMax - b.rMin) * PANEL_SIZE,
    y: (i - b.iMin) / (b.iMax - b.iMin) * PANEL_SIZE,
  };
}

function pixelToC(familyIdx, px, py) {
  const b = panelState[familyIdx].bounds;
  return {
    r: b.rMin + (px / PANEL_SIZE) * (b.rMax - b.rMin),
    i: b.iMin + (py / PANEL_SIZE) * (b.iMax - b.iMin),
  };
}

function drawOverlay(familyIdx) {
  const ps = panelState[familyIdx];
  const ctx = ps.canvas.getContext('2d');
  ctx.drawImage(ps.locusBuffer, 0, 0);

  const pxPerC = PANEL_SIZE / (ps.bounds.rMax - ps.bounds.rMin);

  // Draw all anchors that belong to this family
  for (let deg = 1; deg <= 7; deg++) {
    const a = anchors[deg];
    if (!a || a.familyIdx !== familyIdx) continue;

    const p = cToPixel(familyIdx, a.real, a.imag);
    const rPx = Math.max(4, a.radius * pxPerC);
    const col = degreeColors[deg];
    const isSelected = deg === selectedDegree;

    // Radius fill
    ctx.globalAlpha = 0.15;
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(p.x, p.y, rPx, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Radius ring
    ctx.beginPath();
    ctx.arc(p.x, p.y, rPx, 0, Math.PI*2);
    ctx.strokeStyle = col + (isSelected ? 'cc' : '66');
    ctx.lineWidth = isSelected ? 2 : 1;
    ctx.stroke();

    // Dot
    ctx.beginPath();
    ctx.arc(p.x, p.y, isSelected ? 6 : 4, 0, Math.PI*2);
    ctx.fillStyle = col;
    ctx.fill();
    if (isSelected) {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }

    // Label
    ctx.font = 'bold 11px monospace';
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#000';
    ctx.strokeText(degreeNames[deg], p.x+8, p.y-6);
    ctx.fillStyle = '#fff';
    ctx.fillText(degreeNames[deg], p.x+8, p.y-6);

    // Resize handle (right edge)
    if (isSelected) {
      ctx.fillStyle = '#fff';
      ctx.fillRect(p.x+rPx-3, p.y-3, 6, 6);
    }
  }
}

function redrawAllOverlays() {
  for (let i = 0; i < families.length; i++) drawOverlay(i);
  updateAssignInfo();
}

// --- Julia preview ---
function showJulia(family, jR, jI) {
  const canvas = document.getElementById('julia-canvas');
  const ctx = canvas.getContext('2d');
  const img = ctx.createImageData(JULIA_SIZE, JULIA_SIZE);
  const d = img.data;
  const range = 3.6, half = range/2, step = range/JULIA_SIZE;

  for (let py=0; py<JULIA_SIZE; py++) {
    for (let px=0; px<JULIA_SIZE; px++) {
      const esc = family.julia(-half+px*step, -half+py*step, jR, jI, JULIA_ITER);
      const idx = (py*JULIA_SIZE+px)*4;
      if (esc === 0) {
        d[idx]=d[idx+1]=d[idx+2]=0;
      } else {
        const t = Math.sqrt(esc/JULIA_ITER);
        d[idx]=Math.min(255, t*200);
        d[idx+1]=Math.min(255, t*220);
        d[idx+2]=Math.min(255, t*255);
      }
      d[idx+3]=255;
    }
  }
  ctx.putImageData(img, 0, 0);
  document.getElementById('julia-info').textContent =
    `${family.label} | c = ${jR.toFixed(4)} + ${jI.toFixed(4)}i`;
}

// --- Assignment info ---
function updateAssignInfo() {
  const div = document.getElementById('assign-info');
  let html = '<strong style="color:#16c79a">Assignments:</strong><br>';
  for (let deg = 1; deg <= 7; deg++) {
    const a = anchors[deg];
    html += `<div class="row">`;
    html += `<span class="dot" style="background:${degreeColors[deg]}"></span>`;
    html += `<strong>${degreeNames[deg]}</strong> `;
    if (a) {
      const f = families[a.familyIdx];
      html += `<span class="type-tag">${f.label}</span> `;
      html += `(${a.real.toFixed(4)}, ${a.imag.toFixed(4)}) r=${a.radius.toFixed(4)}`;
    } else {
      html += `<span style="color:#555">unassigned</span>`;
    }
    html += `</div>`;
  }
  div.innerHTML = html;
}

// --- Mouse interaction per panel ---
function setupPanel(familyIdx) {
  const f = families[familyIdx];
  const ps = panelState[familyIdx];

  const wrap = document.createElement('div');
  wrap.className = 'panel';

  const h2 = document.createElement('h2');
  h2.textContent = f.label;
  wrap.appendChild(h2);

  const canvas = document.createElement('canvas');
  canvas.width = PANEL_SIZE;
  canvas.height = PANEL_SIZE;
  wrap.appendChild(canvas);
  ps.canvas = canvas;

  ps.locusBuffer = document.createElement('canvas');
  ps.locusBuffer.width = PANEL_SIZE;
  ps.locusBuffer.height = PANEL_SIZE;

  document.getElementById('panels').appendChild(wrap);

  // --- Drag state ---
  let dragMode = null; // 'anchor' | 'resize' | 'pan'
  let dragDeg = -1;
  let dragStartMx, dragStartMy;
  let dragStartData = {};
  let isDragging = false;
  let renderTimeout = null;

  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * PANEL_SIZE / rect.width,
      y: (e.clientY - rect.top) * PANEL_SIZE / rect.height,
    };
  }

  function hitTest(mx, my) {
    const pxPerC = PANEL_SIZE / (ps.bounds.rMax - ps.bounds.rMin);
    // Check selected degree's resize handle first
    const sa = anchors[selectedDegree];
    if (sa && sa.familyIdx === familyIdx) {
      const p = cToPixel(familyIdx, sa.real, sa.imag);
      const rPx = Math.max(4, sa.radius * pxPerC);
      if (Math.abs(Math.hypot(mx-p.x, my-p.y) - rPx) < 6)
        return { type:'resize', deg:selectedDegree };
    }
    // Check anchor dots
    for (let deg = 1; deg <= 7; deg++) {
      const a = anchors[deg];
      if (!a || a.familyIdx !== familyIdx) continue;
      const p = cToPixel(familyIdx, a.real, a.imag);
      if (Math.hypot(mx-p.x, my-p.y) < 8) return { type:'anchor', deg };
    }
    return { type:'empty' };
  }

  canvas.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    const pos = getPos(e);
    const hit = hitTest(pos.x, pos.y);
    dragStartMx = e.clientX;
    dragStartMy = e.clientY;
    isDragging = false;

    if (hit.type === 'anchor') {
      dragMode = 'anchor';
      dragDeg = hit.deg;
      selectedDegree = hit.deg;
      selectDegree(hit.deg);
      const a = anchors[hit.deg];
      dragStartData = { real: a.real, imag: a.imag };
      canvas.style.cursor = 'move';
    } else if (hit.type === 'resize') {
      dragMode = 'resize';
      dragDeg = selectedDegree;
      canvas.style.cursor = 'ew-resize';
    } else {
      dragMode = 'pan';
      dragStartData = { ...ps.bounds };
      canvas.style.cursor = 'grabbing';
    }
  });

  window.addEventListener('mousemove', (e) => {
    if (dragMode === null) return;
    // Check if this drag belongs to this panel
    const rect = canvas.getBoundingClientRect();
    if (dragMode === 'pan' && dragStartData.rMin === undefined) return;

    const dx = e.clientX - dragStartMx;
    const dy = e.clientY - dragStartMy;
    if (Math.abs(dx) > 3 || Math.abs(dy) > 3) isDragging = true;
    if (!isDragging) return;

    const cDx = dx * (ps.bounds.rMax - ps.bounds.rMin) / rect.width;
    const cDy = dy * (ps.bounds.iMax - ps.bounds.iMin) / rect.height;

    if (dragMode === 'anchor' && anchors[dragDeg]?.familyIdx === familyIdx) {
      anchors[dragDeg].real = dragStartData.real + cDx;
      anchors[dragDeg].imag = dragStartData.imag + cDy;
      if (dragDeg === 1) { anchors[0] = { ...anchors[1] }; }
      redrawAllOverlays();
    } else if (dragMode === 'resize' && anchors[dragDeg]?.familyIdx === familyIdx) {
      const a = anchors[dragDeg];
      const pos = getPos(e);
      const p = cToPixel(familyIdx, a.real, a.imag);
      const distPx = Math.hypot(pos.x-p.x, pos.y-p.y);
      const pxPerC = PANEL_SIZE / (ps.bounds.rMax - ps.bounds.rMin);
      a.radius = Math.max(0.003, distPx / pxPerC);
      if (dragDeg === 1 && anchors[0]) anchors[0].radius = a.radius;
      redrawAllOverlays();
    } else if (dragMode === 'pan') {
      const pDx = -dx * (dragStartData.rMax - dragStartData.rMin) / rect.width;
      const pDy = -dy * (dragStartData.iMax - dragStartData.iMin) / rect.height;
      ps.bounds.rMin = dragStartData.rMin + pDx;
      ps.bounds.rMax = dragStartData.rMax + pDx;
      ps.bounds.iMin = dragStartData.iMin + pDy;
      ps.bounds.iMax = dragStartData.iMax + pDy;
      if (renderTimeout) clearTimeout(renderTimeout);
      renderTimeout = setTimeout(() => { renderLocus(familyIdx); drawOverlay(familyIdx); }, 100);
    }
  });

  window.addEventListener('mouseup', (e) => {
    if (dragMode === null) return;
    canvas.style.cursor = 'crosshair';

    if (!isDragging && dragMode !== 'resize') {
      if (dragMode === 'anchor') {
        // Click on existing anchor — just select
        showJulia(f, anchors[dragDeg].real, anchors[dragDeg].imag);
      } else {
        // Click on empty space — place/move selected degree here
        const pos = getPos(e);
        const c = pixelToC(familyIdx, pos.x, pos.y);
        const existingRadius = anchors[selectedDegree]?.radius || DEFAULT_RADIUS;
        anchors[selectedDegree] = {
          familyIdx,
          real: c.r,
          imag: c.i,
          radius: existingRadius,
        };
        // Keep 0 in sync with 1
        if (selectedDegree === 1) anchors[0] = { ...anchors[selectedDegree] };
        showJulia(f, c.r, c.i);
        redrawAllOverlays();
      }
    } else if (dragMode === 'anchor' || dragMode === 'resize') {
      const a = anchors[dragDeg];
      if (a) showJulia(families[a.familyIdx], a.real, a.imag);
    }

    dragMode = null;
    isDragging = false;
  });

  // Zoom
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const pos = getPos(e);
    const c = pixelToC(familyIdx, pos.x, pos.y);
    const factor = e.deltaY < 0 ? 0.7 : 1.4;
    const newW = (ps.bounds.rMax - ps.bounds.rMin) * factor;
    const newH = (ps.bounds.iMax - ps.bounds.iMin) * factor;
    const fracX = pos.x / PANEL_SIZE;
    const fracY = pos.y / PANEL_SIZE;
    ps.bounds.rMin = c.r - fracX * newW;
    ps.bounds.rMax = c.r + (1 - fracX) * newW;
    ps.bounds.iMin = c.i - fracY * newH;
    ps.bounds.iMax = c.i + (1 - fracY) * newH;
    const origW = ps.origBounds.rMax - ps.origBounds.rMin;
    ps.zoomLevel = origW / (ps.bounds.rMax - ps.bounds.rMin);
    renderLocus(familyIdx);
    drawOverlay(familyIdx);
  }, { passive: false });

  // Double-click to reset
  canvas.addEventListener('dblclick', () => {
    ps.bounds = { ...ps.origBounds };
    ps.zoomLevel = 1.0;
    renderLocus(familyIdx);
    drawOverlay(familyIdx);
  });

  // Hover
  canvas.addEventListener('mousemove', (e) => {
    if (dragMode) return;
    const pos = getPos(e);
    const c = pixelToC(familyIdx, pos.x, pos.y);
    document.getElementById('status').textContent =
      `${f.label} | c = ${c.r.toFixed(4)} + ${c.i.toFixed(4)}i`;
  });
}

// --- Export ---
document.getElementById('export-btn').addEventListener('click', () => {
  let lines = `const mixedAnchors: Record<number, CValue> = {\n`;
  for (let deg = 0; deg <= 7; deg++) {
    const a = anchors[deg];
    if (!a) {
      lines += `  // ${deg}: not assigned\n`;
      continue;
    }
    const f = families[a.familyIdx];
    const sr = a.real + a.radius;
    lines += `  ${deg}: { real: ${a.real.toFixed(4)}, imag: ${a.imag.toFixed(4)}, type: ${f.typeNum},\n`;
    lines += `       sweepTo: { real: ${sr.toFixed(4)}, imag: ${a.imag.toFixed(4)} } },`;
    lines += `  // ${f.label}, radius=${a.radius.toFixed(4)}\n`;
  }
  lines += '};';
  navigator.clipboard.writeText(lines).then(() => alert('Copied to clipboard!'));
});

document.getElementById('clear-btn').addEventListener('click', () => {
  anchors.fill(null);
  redrawAllOverlays();
});

// --- Init ---
buildDegreeBar();
for (let i = 0; i < families.length; i++) setupPanel(i);

// Render all loci
document.getElementById('status').textContent = 'Rendering...';
setTimeout(() => {
  for (let i = 0; i < families.length; i++) {
    renderLocus(i);
    drawOverlay(i);
  }
  document.getElementById('status').textContent = 'Ready. Select a degree, click a panel to place.';
}, 30);
</script>
</body>
</html>
